{"version":3,"file":"search-params.cjs.production.min.js","sources":["../src/encode.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["export type arrayFormat = 'none' | 'brackets' | 'index'\nexport type booleanFormat = 'none' | 'string' | 'unicode' | 'empty-true'\nexport type nullFormat = 'default' | 'string' | 'hidden'\n\nexport interface IOptions {\n  arrayFormat?: arrayFormat\n  booleanFormat?: booleanFormat\n  nullFormat?: nullFormat\n}\n\nexport interface IFinalOptions {\n  arrayFormat: arrayFormat\n  booleanFormat: booleanFormat\n  nullFormat: nullFormat\n}\n\nexport const makeOptions = (opts: IOptions = {}): IFinalOptions => ({\n  arrayFormat: opts.arrayFormat || 'none',\n  booleanFormat: opts.booleanFormat || 'none',\n  nullFormat: opts.nullFormat || 'default'\n})\n\nconst encodeValue = (value: any): string => encodeURIComponent(value)\n\nconst decodeValue = (value: string): string => decodeURIComponent(value)\n\nconst encodeBoolean = (\n  name: string,\n  value: boolean,\n  opts: IFinalOptions\n): string => {\n  if (opts.booleanFormat === 'empty-true' && value) {\n    return name\n  }\n\n  let encodedValue\n\n  if (opts.booleanFormat === 'unicode') {\n    encodedValue = value ? '✓' : '✗'\n  } else {\n    encodedValue = value.toString()\n  }\n\n  return `${name}=${encodedValue}`\n}\n\nconst encodeNull = (name: string, opts: IFinalOptions): string => {\n  if (opts.nullFormat === 'hidden') {\n    return ''\n  }\n\n  if (opts.nullFormat === 'string') {\n    return `${name}=null`\n  }\n\n  return name\n}\n\ntype nameEncoder = (val: string, index: number) => string\n\nconst getNameEncoder = (opts: IFinalOptions): nameEncoder => {\n  if (opts.arrayFormat === 'index') {\n    return (name: string, index: number): string => `${name}[${index}]`\n  }\n\n  if (opts.arrayFormat === 'brackets') {\n    return (name: string): string => `${name}[]`\n  }\n\n  return (name: string): string => name\n}\n\nexport const encodeArray = (\n  name: string,\n  arr: any[],\n  opts: IFinalOptions\n): string => {\n  const encodeName = getNameEncoder(opts)\n\n  return arr\n    .map((val, index) => `${encodeName(name, index)}=${encodeValue(val)}`)\n    .join('&')\n}\n\nexport const encode = (\n  name: string,\n  value: any,\n  opts: IFinalOptions\n): string => {\n  if (value === null) {\n    return encodeNull(name, opts)\n  }\n\n  if (typeof value === 'boolean') {\n    return encodeBoolean(name, value, opts)\n  }\n\n  if (Array.isArray(value)) {\n    return encodeArray(name, value, opts)\n  }\n\n  return `${name}=${encodeValue(value)}`\n}\n\nexport const decode = (\n  value: any,\n  opts: IFinalOptions\n): boolean | string | null => {\n  if (value === undefined) {\n    return opts.booleanFormat === 'empty-true' ? true : null\n  }\n\n  if (opts.booleanFormat === 'string') {\n    if (value === 'true') {\n      return true\n    }\n    if (value === 'false') {\n      return false\n    }\n  }\n\n  if (opts.booleanFormat === 'unicode') {\n    if (decodeValue(value) === '✓') {\n      return true\n    }\n    if (decodeValue(value) === '✗') {\n      return false\n    }\n  }\n\n  if (opts.nullFormat === 'string') {\n    if (value === 'null') {\n      return null\n    }\n  }\n\n  return decodeValue(value)\n}\n","export const getSearch = (path: string): string => {\n  const pos = path.indexOf('?')\n\n  if (pos === -1) {\n    return path\n  }\n\n  return path.slice(pos + 1)\n}\n\nexport const isSerialisable = (val: any): boolean => val !== undefined\n\nexport interface IParsedName {\n  hasBrackets: boolean\n  name: string\n}\n\nexport const parseName = (name: string): IParsedName => {\n  const bracketPosition = name.indexOf('[')\n  const hasBrackets = bracketPosition !== -1\n\n  return {\n    hasBrackets,\n    name: hasBrackets ? name.slice(0, bracketPosition) : name\n  }\n}\n","import { decode, encode, IOptions, makeOptions } from './encode'\nimport { getSearch, isSerialisable, parseName } from './utils'\n\nexport { IOptions }\n\nexport type SearchParams = Record<\n  string,\n  string | boolean | null | Array<string | boolean | null> | undefined\n>\n\n/**\n * Parse a querystring and return an object of parameters\n */\nexport const parse = <T extends Record<string, any> = SearchParams>(\n  path: string,\n  opts?: IOptions\n): T => {\n  const options = makeOptions(opts)\n\n  return getSearch(path)\n    .split('&')\n    .reduce<Record<string, any>>((params, param) => {\n      const [rawName, value] = param.split('=')\n      const { hasBrackets, name } = parseName(rawName)\n      const currentValue = params[name]\n      const decodedValue = decode(value, options)\n\n      if (currentValue === undefined) {\n        params[name] = hasBrackets ? [decodedValue] : decodedValue\n      } else {\n        params[name] = (Array.isArray(currentValue)\n          ? currentValue\n          : [currentValue]\n        ).concat(decodedValue)\n      }\n\n      return params\n    }, {}) as T\n}\n\n/**\n * Build a querystring from an object of parameters\n */\nexport const build = <T extends Record<string, any> = SearchParams>(\n  params: T,\n  opts?: IOptions\n): string => {\n  const options = makeOptions(opts)\n\n  return Object.keys(params)\n    .filter(paramName => isSerialisable(params[paramName]))\n    .map(paramName => encode(paramName, params[paramName], options))\n    .filter(Boolean)\n    .join('&')\n}\n\nexport interface IOmitResponse {\n  querystring: string\n  removedParams: object\n}\n\n/**\n * Remove a list of parameters from a querystring\n */\nexport const omit = (\n  path: string,\n  paramsToOmit: string[],\n  opts?: IOptions\n): IOmitResponse => {\n  const options = makeOptions(opts)\n  const searchPart = getSearch(path)\n  if (searchPart === '') {\n    return {\n      querystring: '',\n      removedParams: {}\n    }\n  }\n\n  const [kept, removed] = path.split('&').reduce<[string[], string[]]>(\n    ([left, right]: [string[], string[]], chunk: string) => {\n      const rawName = chunk.split('=')[0]\n      const { name } = parseName(rawName)\n\n      return paramsToOmit.indexOf(name) === -1\n        ? [left.concat(chunk), right]\n        : [left, right.concat(chunk)]\n    },\n    [[], []]\n  )\n\n  return {\n    querystring: kept.join('&'),\n    removedParams: parse(removed.join('&'), options)\n  }\n}\n\nexport interface IKeepResponse {\n  querystring: string\n  keptParams: object\n}\n\n/**\n * Remove a list of parameters from a querystring\n */\nexport const keep = (\n  path: string,\n  paramsToKeep: string[],\n  opts?: IOptions\n): IKeepResponse => {\n  const options = makeOptions(opts)\n  const searchPart = getSearch(path)\n  if (searchPart === '') {\n    return {\n      keptParams: {},\n      querystring: ''\n    }\n  }\n\n  const kept = path.split('&').reduce<string[]>((acc, chunk: string) => {\n    const rawName = chunk.split('=')[0]\n    const { name } = parseName(rawName)\n\n    if (paramsToKeep.includes(name)) {\n      acc.push(chunk)\n    }\n\n    return acc\n  }, [])\n\n  return {\n    keptParams: parse(kept.join('&'), options),\n    querystring: kept.join('&')\n  }\n}\n"],"names":["makeOptions","opts","arrayFormat","booleanFormat","nullFormat","encodeValue","value","encodeURIComponent","decodeValue","decodeURIComponent","getSearch","path","pos","indexOf","slice","parseName","name","bracketPosition","hasBrackets","parse","options","split","reduce","params","param","_a","_b","currentValue","decodedValue","undefined","decode","Array","isArray","concat","Object","keys","filter","paramName","map","encodeNull","toString","encodeBoolean","arr","encodeName","index","getNameEncoder","val","join","encodeArray","encode","Boolean","paramsToKeep","keptParams","querystring","kept","acc","chunk","rawName","includes","push","paramsToOmit","removedParams","removed"],"mappings":"oEAgBO,IAAMA,EAAc,SAACC,uBAAAA,MAAwC,CAClEC,YAAaD,EAAKC,aAAe,OACjCC,cAAeF,EAAKE,eAAiB,OACrCC,WAAYH,EAAKG,YAAc,YAG3BC,EAAc,SAACC,UAAuBC,mBAAmBD,IAEzDE,EAAc,SAACF,UAA0BG,mBAAmBH,ICxBrDI,EAAY,SAACC,OAClBC,EAAMD,EAAKE,QAAQ,YAEZ,IAATD,EACKD,EAGFA,EAAKG,MAAMF,EAAM,IAUbG,EAAY,SAACC,OAClBC,EAAkBD,EAAKH,QAAQ,KAC/BK,GAAmC,IAArBD,QAEb,CACLC,cACAF,KAAME,EAAcF,EAAKF,MAAM,EAAGG,GAAmBD,ICV5CG,EAAQ,SACnBR,EACAV,OAEMmB,EAAUpB,EAAYC,UAErBS,EAAUC,GACdU,MAAM,KACNC,QAA4B,SAACC,EAAQC,OAC9BC,eAAUnB,OACVoB,UAAER,gBAAaF,SACfW,EAAeJ,EAAOP,GACtBY,EF+EU,SACpBtB,EACAL,WAEc4B,IAAVvB,QAC4B,eAAvBL,EAAKE,eAAwC,QAG3B,WAAvBF,EAAKE,cAA4B,IACrB,SAAVG,SACK,KAEK,UAAVA,SACK,KAIgB,YAAvBL,EAAKE,cAA6B,IACT,MAAvBK,EAAYF,UACP,KAEkB,MAAvBE,EAAYF,UACP,QAIa,WAApBL,EAAKG,YACO,SAAVE,EACK,KAIJE,EAAYF,GE/GMwB,CAAOxB,EAAOc,UAGjCG,EAAOP,QADYa,IAAjBF,EACaT,EAAc,CAACU,GAAgBA,GAE9BG,MAAMC,QAAQL,GAC1BA,EACA,CAACA,IACHM,OAAOL,GAGJL,IACN,mBAMc,SACnBA,EACAtB,OAEMmB,EAAUpB,EAAYC,UAErBiC,OAAOC,KAAKZ,GAChBa,QAAO,SAAAC,eDxCiDR,ICwCrBN,EAAOc,MAC1CC,KAAI,SAAAD,UFiCa,SACpBrB,EACAV,EACAL,UAEc,OAAVK,EA3Ca,SAACU,EAAcf,SACR,WAApBA,EAAKG,WACA,GAGe,WAApBH,EAAKG,WACGY,UAGLA,EAmCEuB,CAAWvB,EAAMf,GAGL,kBAAVK,EAnES,SACpBU,EACAV,EACAL,SAE2B,eAAvBA,EAAKE,eAAkCG,EAClCU,EAWCA,OANiB,YAAvBf,EAAKE,cACQG,EAAQ,IAAM,IAEdA,EAAMkC,YAsDdC,CAAczB,EAAMV,EAAOL,GAGhC8B,MAAMC,QAAQ1B,GAzBO,SACzBU,EACA0B,EACAzC,OAEM0C,EAjBe,SAAC1C,SACG,UAArBA,EAAKC,YACA,SAACc,EAAc4B,UAA6B5B,MAAQ4B,OAGpC,aAArB3C,EAAKC,YACA,SAACc,UAA4BA,QAG/B,SAACA,UAAyBA,GAQd6B,CAAe5C,UAE3ByC,EACJJ,KAAI,SAACQ,EAAKF,UAAaD,EAAW3B,EAAM4B,OAAUvC,EAAYyC,MAC9DC,KAAK,KAiBCC,CAAYhC,EAAMV,EAAOL,GAGxBe,MAAQX,EAAYC,GElDV2C,CAAOZ,EAAWd,EAAOc,GAAYjB,MACtDgB,OAAOc,SACPH,KAAK,mBAmDU,SAClBpC,EACAwC,EACAlD,OAEMmB,EAAUpB,EAAYC,MAET,KADAS,EAAUC,SAEpB,CACLyC,WAAY,GACZC,YAAa,QAIXC,EAAO3C,EAAKU,MAAM,KAAKC,QAAiB,SAACiC,EAAKC,OAC5CC,EAAUD,EAAMnC,MAAM,KAAK,GACzBL,mBAEJmC,EAAaO,SAAS1C,IACxBuC,EAAII,KAAKH,GAGJD,IACN,UAEI,CACLH,WAAYjC,EAAMmC,EAAKP,KAAK,KAAM3B,GAClCiC,YAAaC,EAAKP,KAAK,oBAnEP,SAClBpC,EACAiD,EACA3D,OAEMmB,EAAUpB,EAAYC,MAET,KADAS,EAAUC,SAEpB,CACL0C,YAAa,GACbQ,cAAe,QAIbpC,wJAAOqC,aAYN,CACLT,iBAAkBN,KAAK,KACvBc,cAAe1C,EAAM2C,EAAQf,KAAK,KAAM3B"}