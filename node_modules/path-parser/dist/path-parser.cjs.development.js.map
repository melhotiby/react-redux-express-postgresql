{"version":3,"file":"path-parser.cjs.development.js","sources":["../src/encoding.ts","../src/rules.ts","../src/tokeniser.ts","../src/Path.ts"],"sourcesContent":["/**\n * We encode using encodeURIComponent but we want to\n * preserver certain characters which are commonly used\n * (sub delimiters and ':')\n * \n * https://www.ietf.org/rfc/rfc3986.txt\n * \n * reserved    = gen-delims / sub-delims\n * \n * gen-delims  = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n * \n * sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n              / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\n\nconst excludeSubDelimiters = /[^!$'()*+,;|:]/g\n\nexport type URLParamsEncodingType =\n  | 'default'\n  | 'uri'\n  | 'uriComponent'\n  | 'none'\n  | 'legacy'\n\nexport const encodeURIComponentExcludingSubDelims = (segment: string): string =>\n  segment.replace(excludeSubDelimiters, match => encodeURIComponent(match))\n\nconst encodingMethods: Record<\n  URLParamsEncodingType,\n  (param: string) => string\n> = {\n  default: encodeURIComponentExcludingSubDelims,\n  uri: encodeURI,\n  uriComponent: encodeURIComponent,\n  none: val => val,\n  legacy: encodeURI\n}\n\nconst decodingMethods: Record<\n  URLParamsEncodingType,\n  (param: string) => string\n> = {\n  default: decodeURIComponent,\n  uri: decodeURI,\n  uriComponent: decodeURIComponent,\n  none: val => val,\n  legacy: decodeURIComponent\n}\n\nexport const encodeParam = (\n  param: string | number | boolean,\n  encoding: URLParamsEncodingType,\n  isSpatParam: boolean\n): string => {\n  const encoder =\n    encodingMethods[encoding] || encodeURIComponentExcludingSubDelims\n\n  if (isSpatParam) {\n    return String(param)\n      .split('/')\n      .map(encoder)\n      .join('/')\n  }\n\n  return encoder(String(param))\n}\n\nexport const decodeParam = (\n  param: string,\n  encoding: URLParamsEncodingType\n): string => (decodingMethods[encoding] || decodeURIComponent)(param)\n","export const defaultOrConstrained = (match: string): string =>\n  '(' +\n  (match ? match.replace(/(^<|>$)/g, '') : \"[a-zA-Z0-9-_.~%':|=+\\\\*@$]+\") +\n  ')'\n\nexport type RegExpFactory = (match: any) => RegExp\n\nexport interface IRule {\n  /* The name of the rule */\n  name: string\n  /* The regular expression used to find a token in a path definition */\n  pattern: RegExp\n  /* The derived regular expression to match a path */\n  regex?: RegExp | RegExpFactory\n}\n\nconst rules: IRule[] = [\n  {\n    name: 'url-parameter',\n    pattern: /^:([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n    regex: (match: RegExpMatchArray) =>\n      new RegExp(defaultOrConstrained(match[2]))\n  },\n  {\n    name: 'url-parameter-splat',\n    pattern: /^\\*([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/,\n    regex: /([^?]*)/\n  },\n  {\n    name: 'url-parameter-matrix',\n    pattern: /^;([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n    regex: (match: RegExpMatchArray) =>\n      new RegExp(';' + match[1] + '=' + defaultOrConstrained(match[2]))\n  },\n  {\n    name: 'query-parameter',\n    pattern: /^(?:\\?|&)(?::)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/\n  },\n  {\n    name: 'delimiter',\n    pattern: /^(\\/|\\?)/,\n    regex: (match: RegExpMatchArray) => new RegExp('\\\\' + match[0])\n  },\n  {\n    name: 'sub-delimiter',\n    pattern: /^(!|&|-|_|\\.|;)/,\n    regex: (match: RegExpMatchArray) => new RegExp(match[0])\n  },\n  {\n    name: 'fragment',\n    pattern: /^([0-9a-zA-Z]+)/,\n    regex: (match: RegExpMatchArray) => new RegExp(match[0])\n  }\n]\n\nexport default rules\n","import rules from './rules'\n\nexport interface Token {\n  type: string\n  match: string\n  val: any\n  otherVal: any\n  regex?: RegExp\n}\n\nconst tokenise = (str: string, tokens: Token[] = []): Token[] => {\n  // Look for a matching rule\n  const matched = rules.some(rule => {\n    const match = str.match(rule.pattern)\n    if (!match) {\n      return false\n    }\n\n    tokens.push({\n      type: rule.name,\n      match: match[0],\n      val: match.slice(1, 2),\n      otherVal: match.slice(2),\n      regex: rule.regex instanceof Function ? rule.regex(match) : rule.regex\n    })\n\n    if (match[0].length < str.length) {\n      tokens = tokenise(str.substr(match[0].length), tokens)\n    }\n    return true\n  })\n\n  // If no rules matched, throw an error (possible malformed path)\n  if (!matched) {\n    throw new Error(`Could not parse path '${str}'`)\n  }\n\n  return tokens\n}\n\nexport default tokenise\n","import {\n  build as buildQueryParams,\n  IOptions,\n  parse as parseQueryParams\n} from 'search-params'\n\nimport { URLParamsEncodingType, decodeParam, encodeParam } from './encoding'\nimport { defaultOrConstrained } from './rules'\nimport tokenise, { Token } from './tokeniser'\n\nexport { URLParamsEncodingType }\n\nconst exists = (val: any) => val !== undefined && val !== null\n\nconst optTrailingSlash = (source: string, strictTrailingSlash: boolean) => {\n  if (strictTrailingSlash) {\n    return source\n  }\n\n  if (source === '\\\\/') {\n    return source\n  }\n\n  return source.replace(/\\\\\\/$/, '') + '(?:\\\\/)?'\n}\n\nconst upToDelimiter = (source: string, delimiter?: boolean) => {\n  if (!delimiter) {\n    return source\n  }\n\n  return /(\\/)$/.test(source) ? source : source + '(\\\\/|\\\\?|\\\\.|;|$)'\n}\n\nconst appendQueryParam = (\n  params: Record<string, any>,\n  param: string,\n  val = ''\n) => {\n  const existingVal = params[param]\n\n  if (existingVal === undefined) {\n    params[param] = val\n  } else {\n    params[param] = Array.isArray(existingVal)\n      ? existingVal.concat(val)\n      : [existingVal, val]\n  }\n\n  return params\n}\n\nexport interface PathOptions {\n  /**\n   * Query parameters buiding and matching options, see\n   * https://github.com/troch/search-params#options\n   */\n  queryParams?: IOptions\n  /**\n   * Specifies the method used to encode URL parameters:\n   *   - `'default': `encodeURIComponent` and `decodeURIComponent`\n   *      are used but some characters to encode and decode URL parameters,\n   *      but some characters are preserved when encoding\n   *      (sub-delimiters: `+`, `:`, `'`, `!`, `,`, `;`, `'*'`).\n   *   - `'uriComponent'`: use `encodeURIComponent` and `decodeURIComponent`\n   *      for encoding and decoding URL parameters.\n   *   - `'uri'`: use `encodeURI` and `decodeURI for encoding amd decoding\n   *      URL parameters.\n   *   - `'none'`: no encoding or decoding is performed\n   *   - `'legacy'`: the approach for version 5.x and below (not recoomended)\n   */\n  urlParamsEncoding?: URLParamsEncodingType\n}\n\nexport interface InternalPathOptions {\n  queryParams?: IOptions\n  urlParamsEncoding: URLParamsEncodingType\n}\n\nconst defaultOptions: InternalPathOptions = {\n  urlParamsEncoding: 'default'\n}\n\nexport interface PathPartialTestOptions extends PathOptions {\n  caseSensitive?: boolean\n  delimited?: boolean\n}\n\nexport interface PathTestOptions extends PathOptions {\n  caseSensitive?: boolean\n  strictTrailingSlash?: boolean\n}\n\nexport interface PathBuildOptions extends PathOptions {\n  ignoreConstraints?: boolean\n  ignoreSearch?: boolean\n}\n\nexport type TestMatch<\n  T extends Record<string, any> = Record<string, any>\n> = T | null\n\nexport class Path<T extends Record<string, any> = Record<string, any>> {\n  public static createPath<T extends Record<string, any> = Record<string, any>>(\n    path: string,\n    options?: PathOptions\n  ) {\n    return new Path<T>(path, options)\n  }\n\n  public path: string\n  public tokens: Token[]\n  public hasUrlParams: boolean\n  public hasSpatParam: boolean\n  public hasMatrixParams: boolean\n  public hasQueryParams: boolean\n  public options: InternalPathOptions\n  public spatParams: string[]\n  public urlParams: string[]\n  public queryParams: string[]\n  public params: string[]\n  public source: string\n\n  constructor(path: string, options?: PathOptions) {\n    if (!path) {\n      throw new Error('Missing path in Path constructor')\n    }\n    this.path = path\n    this.options = {\n      ...defaultOptions,\n      ...options\n    }\n    this.tokens = tokenise(path)\n\n    this.hasUrlParams =\n      this.tokens.filter(t => /^url-parameter/.test(t.type)).length > 0\n    this.hasSpatParam =\n      this.tokens.filter(t => /splat$/.test(t.type)).length > 0\n    this.hasMatrixParams =\n      this.tokens.filter(t => /matrix$/.test(t.type)).length > 0\n    this.hasQueryParams =\n      this.tokens.filter(t => /^query-parameter/.test(t.type)).length > 0\n    // Extract named parameters from tokens\n    this.spatParams = this.getParams('url-parameter-splat')\n    this.urlParams = this.getParams(/^url-parameter/)\n    // Query params\n    this.queryParams = this.getParams('query-parameter')\n    // All params\n    this.params = this.urlParams.concat(this.queryParams)\n    // Check if hasQueryParams\n    // Regular expressions for url part only (full and partial match)\n    this.source = this.tokens\n      .filter(t => t.regex !== undefined)\n      .map(t => t.regex!.source)\n      .join('')\n  }\n\n  public isQueryParam(name: string): boolean {\n    return this.queryParams.indexOf(name) !== -1\n  }\n\n  public isSpatParam(name: string): boolean {\n    return this.spatParams.indexOf(name) !== -1\n  }\n\n  public test(path: string, opts?: PathTestOptions): TestMatch<T> {\n    const options = {\n      caseSensitive: false,\n      strictTrailingSlash: false,\n      ...this.options,\n      ...opts\n    } as const\n    // trailingSlash: falsy => non optional, truthy => optional\n    const source = optTrailingSlash(this.source, options.strictTrailingSlash)\n    // Check if exact match\n    const match = this.urlTest(\n      path,\n      source + (this.hasQueryParams ? '(\\\\?.*$|$)' : '$'),\n      options.caseSensitive,\n      options.urlParamsEncoding\n    )\n    // If no match, or no query params, no need to go further\n    if (!match || !this.hasQueryParams) {\n      return match\n    }\n    // Extract query params\n    const queryParams = parseQueryParams(path, options.queryParams)\n    const unexpectedQueryParams = Object.keys(queryParams).filter(\n      p => !this.isQueryParam(p)\n    )\n\n    if (unexpectedQueryParams.length === 0) {\n      // Extend url match\n      Object.keys(queryParams).forEach(\n        // @ts-ignore\n        p => (match[p] = (queryParams as any)[p])\n      )\n\n      return match\n    }\n\n    return null\n  }\n\n  public partialTest(\n    path: string,\n    opts?: PathPartialTestOptions\n  ): TestMatch<T> {\n    const options = {\n      caseSensitive: false,\n      delimited: true,\n      ...this.options,\n      ...opts\n    } as const\n    // Check if partial match (start of given path matches regex)\n    // trailingSlash: falsy => non optional, truthy => optional\n    const source = upToDelimiter(this.source, options.delimited)\n    const match = this.urlTest(\n      path,\n      source,\n      options.caseSensitive,\n      options.urlParamsEncoding\n    )\n\n    if (!match) {\n      return match\n    }\n\n    if (!this.hasQueryParams) {\n      return match\n    }\n\n    const queryParams = parseQueryParams(path, options.queryParams)\n\n    Object.keys(queryParams)\n      .filter(p => this.isQueryParam(p))\n      .forEach(p => appendQueryParam(match, p, (queryParams as any)[p]))\n\n    return match\n  }\n\n  public build(params: T = {} as T, opts?: PathBuildOptions): string {\n    const options = {\n      ignoreConstraints: false,\n      ignoreSearch: false,\n      queryParams: {},\n      ...this.options,\n      ...opts\n    } as const\n    const encodedUrlParams = Object.keys(params)\n      .filter(p => !this.isQueryParam(p))\n      .reduce<Record<string, any>>((acc, key) => {\n        if (!exists(params[key])) {\n          return acc\n        }\n\n        const val = params[key]\n        const isSpatParam = this.isSpatParam(key)\n\n        if (typeof val === 'boolean') {\n          acc[key] = val\n        } else if (Array.isArray(val)) {\n          acc[key] = val.map(v =>\n            encodeParam(v, options.urlParamsEncoding, isSpatParam)\n          )\n        } else {\n          acc[key] = encodeParam(val, options.urlParamsEncoding, isSpatParam)\n        }\n\n        return acc\n      }, {})\n\n    // Check all params are provided (not search parameters which are optional)\n    if (this.urlParams.some(p => !exists(params[p]))) {\n      const missingParameters = this.urlParams.filter(p => !exists(params[p]))\n      throw new Error(\n        \"Cannot build path: '\" +\n          this.path +\n          \"' requires missing parameters { \" +\n          missingParameters.join(', ') +\n          ' }'\n      )\n    }\n\n    // Check constraints\n    if (!options.ignoreConstraints) {\n      const constraintsPassed = this.tokens\n        .filter(t => /^url-parameter/.test(t.type) && !/-splat$/.test(t.type))\n        .every(t =>\n          new RegExp('^' + defaultOrConstrained(t.otherVal[0]) + '$').test(\n            encodedUrlParams[t.val]\n          )\n        )\n\n      if (!constraintsPassed) {\n        throw new Error(\n          `Some parameters of '${this.path}' are of invalid format`\n        )\n      }\n    }\n\n    const base = this.tokens\n      .filter(t => /^query-parameter/.test(t.type) === false)\n      .map(t => {\n        if (t.type === 'url-parameter-matrix') {\n          return `;${t.val}=${encodedUrlParams[t.val[0]]}`\n        }\n\n        return /^url-parameter/.test(t.type)\n          ? encodedUrlParams[t.val[0]]\n          : t.match\n      })\n      .join('')\n\n    if (options.ignoreSearch) {\n      return base\n    }\n\n    const searchParams = this.queryParams\n      .filter(p => Object.keys(params).indexOf(p) !== -1)\n      .reduce<Record<string, any>>((sparams, paramName) => {\n        sparams[paramName] = params[paramName]\n        return sparams\n      }, {})\n    const searchPart = buildQueryParams(searchParams, options.queryParams)\n\n    return searchPart ? base + '?' + searchPart : base\n  }\n\n  private getParams(type: string | RegExp): string[] {\n    const predicate =\n      type instanceof RegExp\n        ? (t: Token) => type.test(t.type)\n        : (t: Token) => t.type === type\n\n    return this.tokens.filter(predicate).map(t => t.val[0])\n  }\n\n  private urlTest(\n    path: string,\n    source: string,\n    caseSensitive: boolean,\n    urlParamsEncoding: URLParamsEncodingType\n  ): TestMatch<T> {\n    const regex = new RegExp('^' + source, caseSensitive ? '' : 'i')\n    const match = path.match(regex)\n    if (!match) {\n      return null\n    } else if (!this.urlParams.length) {\n      return {} as T\n    }\n    // Reduce named params to key-value pairs\n    return match\n      .slice(1, this.urlParams.length + 1)\n      .reduce<Record<string, any>>((params, m, i) => {\n        params[this.urlParams[i]] = decodeParam(m, urlParamsEncoding)\n        return params\n      }, {}) as T\n  }\n}\n\nexport default Path\n"],"names":["excludeSubDelimiters","encodeURIComponentExcludingSubDelims","segment","replace","match","encodeURIComponent","encodingMethods","uri","encodeURI","uriComponent","none","val","legacy","decodingMethods","decodeURIComponent","decodeURI","encodeParam","param","encoding","isSpatParam","encoder","String","split","map","join","decodeParam","defaultOrConstrained","rules","name","pattern","regex","RegExp","tokenise","str","tokens","matched","some","rule","push","type","slice","otherVal","Function","length","substr","Error","exists","undefined","optTrailingSlash","source","strictTrailingSlash","upToDelimiter","delimiter","test","appendQueryParam","params","existingVal","Array","isArray","concat","defaultOptions","urlParamsEncoding","path","options","hasUrlParams","filter","t","hasSpatParam","hasMatrixParams","hasQueryParams","spatParams","getParams","urlParams","queryParams","Path","indexOf","opts","__assign","caseSensitive","urlTest","parseQueryParams","unexpectedQueryParams","Object","keys","p","_this","isQueryParam","forEach","delimited","ignoreConstraints","ignoreSearch","encodedUrlParams","reduce","acc","key","v","missingParameters","constraintsPassed","every","base","searchParams","sparams","paramName","searchPart","buildQueryParams","predicate","m","i"],"mappings":"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"}