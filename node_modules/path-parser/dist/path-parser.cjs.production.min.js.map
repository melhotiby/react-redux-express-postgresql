{"version":3,"file":"path-parser.cjs.production.min.js","sources":["../src/encoding.ts","../src/rules.ts","../src/tokeniser.ts","../src/Path.ts"],"sourcesContent":["/**\n * We encode using encodeURIComponent but we want to\n * preserver certain characters which are commonly used\n * (sub delimiters and ':')\n * \n * https://www.ietf.org/rfc/rfc3986.txt\n * \n * reserved    = gen-delims / sub-delims\n * \n * gen-delims  = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n * \n * sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n              / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\n\nconst excludeSubDelimiters = /[^!$'()*+,;|:]/g\n\nexport type URLParamsEncodingType =\n  | 'default'\n  | 'uri'\n  | 'uriComponent'\n  | 'none'\n  | 'legacy'\n\nexport const encodeURIComponentExcludingSubDelims = (segment: string): string =>\n  segment.replace(excludeSubDelimiters, match => encodeURIComponent(match))\n\nconst encodingMethods: Record<\n  URLParamsEncodingType,\n  (param: string) => string\n> = {\n  default: encodeURIComponentExcludingSubDelims,\n  uri: encodeURI,\n  uriComponent: encodeURIComponent,\n  none: val => val,\n  legacy: encodeURI\n}\n\nconst decodingMethods: Record<\n  URLParamsEncodingType,\n  (param: string) => string\n> = {\n  default: decodeURIComponent,\n  uri: decodeURI,\n  uriComponent: decodeURIComponent,\n  none: val => val,\n  legacy: decodeURIComponent\n}\n\nexport const encodeParam = (\n  param: string | number | boolean,\n  encoding: URLParamsEncodingType,\n  isSpatParam: boolean\n): string => {\n  const encoder =\n    encodingMethods[encoding] || encodeURIComponentExcludingSubDelims\n\n  if (isSpatParam) {\n    return String(param)\n      .split('/')\n      .map(encoder)\n      .join('/')\n  }\n\n  return encoder(String(param))\n}\n\nexport const decodeParam = (\n  param: string,\n  encoding: URLParamsEncodingType\n): string => (decodingMethods[encoding] || decodeURIComponent)(param)\n","export const defaultOrConstrained = (match: string): string =>\n  '(' +\n  (match ? match.replace(/(^<|>$)/g, '') : \"[a-zA-Z0-9-_.~%':|=+\\\\*@$]+\") +\n  ')'\n\nexport type RegExpFactory = (match: any) => RegExp\n\nexport interface IRule {\n  /* The name of the rule */\n  name: string\n  /* The regular expression used to find a token in a path definition */\n  pattern: RegExp\n  /* The derived regular expression to match a path */\n  regex?: RegExp | RegExpFactory\n}\n\nconst rules: IRule[] = [\n  {\n    name: 'url-parameter',\n    pattern: /^:([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n    regex: (match: RegExpMatchArray) =>\n      new RegExp(defaultOrConstrained(match[2]))\n  },\n  {\n    name: 'url-parameter-splat',\n    pattern: /^\\*([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/,\n    regex: /([^?]*)/\n  },\n  {\n    name: 'url-parameter-matrix',\n    pattern: /^;([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n    regex: (match: RegExpMatchArray) =>\n      new RegExp(';' + match[1] + '=' + defaultOrConstrained(match[2]))\n  },\n  {\n    name: 'query-parameter',\n    pattern: /^(?:\\?|&)(?::)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/\n  },\n  {\n    name: 'delimiter',\n    pattern: /^(\\/|\\?)/,\n    regex: (match: RegExpMatchArray) => new RegExp('\\\\' + match[0])\n  },\n  {\n    name: 'sub-delimiter',\n    pattern: /^(!|&|-|_|\\.|;)/,\n    regex: (match: RegExpMatchArray) => new RegExp(match[0])\n  },\n  {\n    name: 'fragment',\n    pattern: /^([0-9a-zA-Z]+)/,\n    regex: (match: RegExpMatchArray) => new RegExp(match[0])\n  }\n]\n\nexport default rules\n","import rules from './rules'\n\nexport interface Token {\n  type: string\n  match: string\n  val: any\n  otherVal: any\n  regex?: RegExp\n}\n\nconst tokenise = (str: string, tokens: Token[] = []): Token[] => {\n  // Look for a matching rule\n  const matched = rules.some(rule => {\n    const match = str.match(rule.pattern)\n    if (!match) {\n      return false\n    }\n\n    tokens.push({\n      type: rule.name,\n      match: match[0],\n      val: match.slice(1, 2),\n      otherVal: match.slice(2),\n      regex: rule.regex instanceof Function ? rule.regex(match) : rule.regex\n    })\n\n    if (match[0].length < str.length) {\n      tokens = tokenise(str.substr(match[0].length), tokens)\n    }\n    return true\n  })\n\n  // If no rules matched, throw an error (possible malformed path)\n  if (!matched) {\n    throw new Error(`Could not parse path '${str}'`)\n  }\n\n  return tokens\n}\n\nexport default tokenise\n","import {\n  build as buildQueryParams,\n  IOptions,\n  parse as parseQueryParams\n} from 'search-params'\n\nimport { URLParamsEncodingType, decodeParam, encodeParam } from './encoding'\nimport { defaultOrConstrained } from './rules'\nimport tokenise, { Token } from './tokeniser'\n\nexport { URLParamsEncodingType }\n\nconst exists = (val: any) => val !== undefined && val !== null\n\nconst optTrailingSlash = (source: string, strictTrailingSlash: boolean) => {\n  if (strictTrailingSlash) {\n    return source\n  }\n\n  if (source === '\\\\/') {\n    return source\n  }\n\n  return source.replace(/\\\\\\/$/, '') + '(?:\\\\/)?'\n}\n\nconst upToDelimiter = (source: string, delimiter?: boolean) => {\n  if (!delimiter) {\n    return source\n  }\n\n  return /(\\/)$/.test(source) ? source : source + '(\\\\/|\\\\?|\\\\.|;|$)'\n}\n\nconst appendQueryParam = (\n  params: Record<string, any>,\n  param: string,\n  val = ''\n) => {\n  const existingVal = params[param]\n\n  if (existingVal === undefined) {\n    params[param] = val\n  } else {\n    params[param] = Array.isArray(existingVal)\n      ? existingVal.concat(val)\n      : [existingVal, val]\n  }\n\n  return params\n}\n\nexport interface PathOptions {\n  /**\n   * Query parameters buiding and matching options, see\n   * https://github.com/troch/search-params#options\n   */\n  queryParams?: IOptions\n  /**\n   * Specifies the method used to encode URL parameters:\n   *   - `'default': `encodeURIComponent` and `decodeURIComponent`\n   *      are used but some characters to encode and decode URL parameters,\n   *      but some characters are preserved when encoding\n   *      (sub-delimiters: `+`, `:`, `'`, `!`, `,`, `;`, `'*'`).\n   *   - `'uriComponent'`: use `encodeURIComponent` and `decodeURIComponent`\n   *      for encoding and decoding URL parameters.\n   *   - `'uri'`: use `encodeURI` and `decodeURI for encoding amd decoding\n   *      URL parameters.\n   *   - `'none'`: no encoding or decoding is performed\n   *   - `'legacy'`: the approach for version 5.x and below (not recoomended)\n   */\n  urlParamsEncoding?: URLParamsEncodingType\n}\n\nexport interface InternalPathOptions {\n  queryParams?: IOptions\n  urlParamsEncoding: URLParamsEncodingType\n}\n\nconst defaultOptions: InternalPathOptions = {\n  urlParamsEncoding: 'default'\n}\n\nexport interface PathPartialTestOptions extends PathOptions {\n  caseSensitive?: boolean\n  delimited?: boolean\n}\n\nexport interface PathTestOptions extends PathOptions {\n  caseSensitive?: boolean\n  strictTrailingSlash?: boolean\n}\n\nexport interface PathBuildOptions extends PathOptions {\n  ignoreConstraints?: boolean\n  ignoreSearch?: boolean\n}\n\nexport type TestMatch<\n  T extends Record<string, any> = Record<string, any>\n> = T | null\n\nexport class Path<T extends Record<string, any> = Record<string, any>> {\n  public static createPath<T extends Record<string, any> = Record<string, any>>(\n    path: string,\n    options?: PathOptions\n  ) {\n    return new Path<T>(path, options)\n  }\n\n  public path: string\n  public tokens: Token[]\n  public hasUrlParams: boolean\n  public hasSpatParam: boolean\n  public hasMatrixParams: boolean\n  public hasQueryParams: boolean\n  public options: InternalPathOptions\n  public spatParams: string[]\n  public urlParams: string[]\n  public queryParams: string[]\n  public params: string[]\n  public source: string\n\n  constructor(path: string, options?: PathOptions) {\n    if (!path) {\n      throw new Error('Missing path in Path constructor')\n    }\n    this.path = path\n    this.options = {\n      ...defaultOptions,\n      ...options\n    }\n    this.tokens = tokenise(path)\n\n    this.hasUrlParams =\n      this.tokens.filter(t => /^url-parameter/.test(t.type)).length > 0\n    this.hasSpatParam =\n      this.tokens.filter(t => /splat$/.test(t.type)).length > 0\n    this.hasMatrixParams =\n      this.tokens.filter(t => /matrix$/.test(t.type)).length > 0\n    this.hasQueryParams =\n      this.tokens.filter(t => /^query-parameter/.test(t.type)).length > 0\n    // Extract named parameters from tokens\n    this.spatParams = this.getParams('url-parameter-splat')\n    this.urlParams = this.getParams(/^url-parameter/)\n    // Query params\n    this.queryParams = this.getParams('query-parameter')\n    // All params\n    this.params = this.urlParams.concat(this.queryParams)\n    // Check if hasQueryParams\n    // Regular expressions for url part only (full and partial match)\n    this.source = this.tokens\n      .filter(t => t.regex !== undefined)\n      .map(t => t.regex!.source)\n      .join('')\n  }\n\n  public isQueryParam(name: string): boolean {\n    return this.queryParams.indexOf(name) !== -1\n  }\n\n  public isSpatParam(name: string): boolean {\n    return this.spatParams.indexOf(name) !== -1\n  }\n\n  public test(path: string, opts?: PathTestOptions): TestMatch<T> {\n    const options = {\n      caseSensitive: false,\n      strictTrailingSlash: false,\n      ...this.options,\n      ...opts\n    } as const\n    // trailingSlash: falsy => non optional, truthy => optional\n    const source = optTrailingSlash(this.source, options.strictTrailingSlash)\n    // Check if exact match\n    const match = this.urlTest(\n      path,\n      source + (this.hasQueryParams ? '(\\\\?.*$|$)' : '$'),\n      options.caseSensitive,\n      options.urlParamsEncoding\n    )\n    // If no match, or no query params, no need to go further\n    if (!match || !this.hasQueryParams) {\n      return match\n    }\n    // Extract query params\n    const queryParams = parseQueryParams(path, options.queryParams)\n    const unexpectedQueryParams = Object.keys(queryParams).filter(\n      p => !this.isQueryParam(p)\n    )\n\n    if (unexpectedQueryParams.length === 0) {\n      // Extend url match\n      Object.keys(queryParams).forEach(\n        // @ts-ignore\n        p => (match[p] = (queryParams as any)[p])\n      )\n\n      return match\n    }\n\n    return null\n  }\n\n  public partialTest(\n    path: string,\n    opts?: PathPartialTestOptions\n  ): TestMatch<T> {\n    const options = {\n      caseSensitive: false,\n      delimited: true,\n      ...this.options,\n      ...opts\n    } as const\n    // Check if partial match (start of given path matches regex)\n    // trailingSlash: falsy => non optional, truthy => optional\n    const source = upToDelimiter(this.source, options.delimited)\n    const match = this.urlTest(\n      path,\n      source,\n      options.caseSensitive,\n      options.urlParamsEncoding\n    )\n\n    if (!match) {\n      return match\n    }\n\n    if (!this.hasQueryParams) {\n      return match\n    }\n\n    const queryParams = parseQueryParams(path, options.queryParams)\n\n    Object.keys(queryParams)\n      .filter(p => this.isQueryParam(p))\n      .forEach(p => appendQueryParam(match, p, (queryParams as any)[p]))\n\n    return match\n  }\n\n  public build(params: T = {} as T, opts?: PathBuildOptions): string {\n    const options = {\n      ignoreConstraints: false,\n      ignoreSearch: false,\n      queryParams: {},\n      ...this.options,\n      ...opts\n    } as const\n    const encodedUrlParams = Object.keys(params)\n      .filter(p => !this.isQueryParam(p))\n      .reduce<Record<string, any>>((acc, key) => {\n        if (!exists(params[key])) {\n          return acc\n        }\n\n        const val = params[key]\n        const isSpatParam = this.isSpatParam(key)\n\n        if (typeof val === 'boolean') {\n          acc[key] = val\n        } else if (Array.isArray(val)) {\n          acc[key] = val.map(v =>\n            encodeParam(v, options.urlParamsEncoding, isSpatParam)\n          )\n        } else {\n          acc[key] = encodeParam(val, options.urlParamsEncoding, isSpatParam)\n        }\n\n        return acc\n      }, {})\n\n    // Check all params are provided (not search parameters which are optional)\n    if (this.urlParams.some(p => !exists(params[p]))) {\n      const missingParameters = this.urlParams.filter(p => !exists(params[p]))\n      throw new Error(\n        \"Cannot build path: '\" +\n          this.path +\n          \"' requires missing parameters { \" +\n          missingParameters.join(', ') +\n          ' }'\n      )\n    }\n\n    // Check constraints\n    if (!options.ignoreConstraints) {\n      const constraintsPassed = this.tokens\n        .filter(t => /^url-parameter/.test(t.type) && !/-splat$/.test(t.type))\n        .every(t =>\n          new RegExp('^' + defaultOrConstrained(t.otherVal[0]) + '$').test(\n            encodedUrlParams[t.val]\n          )\n        )\n\n      if (!constraintsPassed) {\n        throw new Error(\n          `Some parameters of '${this.path}' are of invalid format`\n        )\n      }\n    }\n\n    const base = this.tokens\n      .filter(t => /^query-parameter/.test(t.type) === false)\n      .map(t => {\n        if (t.type === 'url-parameter-matrix') {\n          return `;${t.val}=${encodedUrlParams[t.val[0]]}`\n        }\n\n        return /^url-parameter/.test(t.type)\n          ? encodedUrlParams[t.val[0]]\n          : t.match\n      })\n      .join('')\n\n    if (options.ignoreSearch) {\n      return base\n    }\n\n    const searchParams = this.queryParams\n      .filter(p => Object.keys(params).indexOf(p) !== -1)\n      .reduce<Record<string, any>>((sparams, paramName) => {\n        sparams[paramName] = params[paramName]\n        return sparams\n      }, {})\n    const searchPart = buildQueryParams(searchParams, options.queryParams)\n\n    return searchPart ? base + '?' + searchPart : base\n  }\n\n  private getParams(type: string | RegExp): string[] {\n    const predicate =\n      type instanceof RegExp\n        ? (t: Token) => type.test(t.type)\n        : (t: Token) => t.type === type\n\n    return this.tokens.filter(predicate).map(t => t.val[0])\n  }\n\n  private urlTest(\n    path: string,\n    source: string,\n    caseSensitive: boolean,\n    urlParamsEncoding: URLParamsEncodingType\n  ): TestMatch<T> {\n    const regex = new RegExp('^' + source, caseSensitive ? '' : 'i')\n    const match = path.match(regex)\n    if (!match) {\n      return null\n    } else if (!this.urlParams.length) {\n      return {} as T\n    }\n    // Reduce named params to key-value pairs\n    return match\n      .slice(1, this.urlParams.length + 1)\n      .reduce<Record<string, any>>((params, m, i) => {\n        params[this.urlParams[i]] = decodeParam(m, urlParamsEncoding)\n        return params\n      }, {}) as T\n  }\n}\n\nexport default Path\n"],"names":["excludeSubDelimiters","encodeURIComponentExcludingSubDelims","segment","replace","match","encodeURIComponent","encodingMethods","uri","encodeURI","uriComponent","none","val","legacy","decodingMethods","decodeURIComponent","decodeURI","encodeParam","param","encoding","isSpatParam","encoder","String","split","map","join","defaultOrConstrained","rules","name","pattern","regex","RegExp","tokenise","str","tokens","some","rule","push","type","slice","otherVal","Function","length","substr","Error","exists","defaultOptions","urlParamsEncoding","path","options","hasUrlParams","this","filter","t","test","hasSpatParam","hasMatrixParams","hasQueryParams","spatParams","getParams","urlParams","queryParams","params","concat","source","undefined","Path","indexOf","opts","__assign","caseSensitive","strictTrailingSlash","optTrailingSlash","urlTest","parseQueryParams","Object","keys","p","_this","isQueryParam","forEach","delimited","delimiter","upToDelimiter","existingVal","Array","isArray","appendQueryParam","ignoreConstraints","ignoreSearch","encodedUrlParams","reduce","acc","key","v","missingParameters","every","base","searchParams","sparams","paramName","searchPart","buildQueryParams","predicate","m","i"],"mappings":"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"}